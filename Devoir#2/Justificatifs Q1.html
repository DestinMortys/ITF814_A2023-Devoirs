--------------Réponse (b)--------------

Dans chacune des trois exécutions décrites, 
Eve a la possibilité de modifier le message sans être détectée par le test de vérification effectué par Bob. 
Cependant, cela dépend du choix de la clé k par Alice et de la modification apportée par Eve.

Exécution 1:
- Alice génère la clé k1 et crée le message m1 = 0b00100011 avec le tag t1.
- Eve modifie le message m1_eve à 0b10100011 (en inversant un bit).
- Bob reçoit m1_eve et t1_eve, puis effectue la vérification. La vérification réussit car il utilise la même clé k1, 
et le tag t1_eve est correct par rapport au message m1_eve.

Dans cette exécution, Eve a réussi à envoyer un message modifié à Bob sans être détectée.

Exécution 2:
- Alice génère la clé k2 et crée le message m2 = 0b10000100 avec le tag t2.
- Eve modifie le message m2_eve à 0b10000101 (en inversant un bit).
- Bob reçoit m2_eve et t2_eve, puis effectue la vérification. La vérification réussit car il utilise la même clé k2, 
et le tag t2_eve est correct par rapport au message m2_eve.

Dans cette exécution, Eve a encore réussi à envoyer un message modifié à Bob sans être détectée.

Exécution 3:
- Alice génère la clé k3 et crée le message m3 = 0b000110001001100010110 avec le tag t3.
- Eve modifie le message m3_eve à 0b000110001001100011110 (en ajoutant un bit).
- Bob reçoit m3_eve et t3_eve, puis effectue la vérification. La vérification réussit car il utilise la même clé k3, 
et le tag t3_eve est correct par rapport au message m3_eve.

Dans cette exécution, Eve a encore réussi à envoyer un message modifié à Bob sans être détectée.

Cependant, il est important de noter que dans chacune de ces exécutions, 
Eve ne peut réussir à envoyer un message de son choix à Bob que si elle connaît la clé utilisée par Alice. 
Une fois que la clé est choisie et fixée, Eve peut modifier les messages correspondants à cette clé sans être détectée. 
Si Eve veut envoyer un message de son choix à Bob après la fin de l'exécution, 
elle devra connaître la clé k utilisée par Alice pour cette session particulière. 
Sans la connaissance de la clé, il est très improbable qu'Eve puisse envoyer un message valide à Bob avec succès, 
car le tag généré dépend de la clé et du message spécifique.

--------------Réponse (c)--------------

La fonction F(k,x)=x⊕k, où k est une clé de longueur n et x est un message de longueur n, n'est pas une fonction pseudo-aléatoire. 
Pour qu'une fonction soit considérée comme pseudo-aléatoire, elle doit avoir certaines propriétés, 
notamment le fait qu'elle soit difficile à distinguer d'une véritable fonction aléatoire lorsque vous regardez ses sorties pour différentes entrées.

Dans ce cas, la fonction F n'est pas pseudo-aléatoire pour les raisons suivantes :

1. F(k, x) est entièrement déterminé par la clé k et l'entrée x. Cela signifie que si vous connaissez la clé k et l'entrée x, 
vous pouvez toujours calculer F(k, x) de manière déterministe. 
Une véritable fonction pseudo-aléatoire produirait des sorties imprévisibles et non déterministes à partir d'entrées données, ce qui n'est pas le cas ici.

2. La fonction F  a une complexité algorithmique très basse. Elle se réduit simplement à une opération XOR (ou OU exclusif), qui est une opération simple et déterministe. 
Une véritable fonction pseudo-aléatoire devrait être basée sur des opérations mathématiques complexes ou des algorithmes cryptographiques bien étudiés pour être considérée comme pseudo-aléatoire.

3. Les sorties de  F  sont directement liées aux entrées  x  et  k  par une opération XOR. 
Il n'y a pas de mélange significatif ou d'élément d'incertitude introduit dans les sorties. 
En revanche, une véritable fonction pseudo-aléatoire présente une variabilité plus importante, 
ce qui signifie que de petites modifications dans les entrées devraient entraîner des changements significatifs dans les sorties.

En résumé, la fonction F(k,x)=x⊕k est déterministe, de faible complexité algorithmique et présente une faible variabilité, 
ce qui en fait une fonction peu appropriée pour être considérée comme pseudo-aléatoire. Pour obtenir une fonction pseudo-aléatoire, 
il est nécessaire d'utiliser des constructions cryptographiques plus sophistiquées et sécurisées, 
telles que des générateurs de nombres pseudo-aléatoires cryptographiques (CSPRNG) basés sur des algorithmes bien étudiés.
